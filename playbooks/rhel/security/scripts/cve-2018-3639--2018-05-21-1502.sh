#!/bin/bash

# Copyright (C) 2018  Red Hat, Inc.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

VERSION="1.0"

# Warning! Be sure to download the latest version of this script from its primary source:

ARTICLE="https://access.redhat.com/security/vulnerabilities/ssbd"

# DO NOT blindly trust any internet sources and NEVER do `curl something | bash`!

# This script is meant for simple detection of the vulnerability. Feel free to modify it for your
# environment or needs. For more advanced detection, consider Red Hat Insights:
# https://access.redhat.com/products/red-hat-insights#getstarted

# Checking against the list of vulnerable packages is necessary because of the way how features
# are back-ported to older versions of packages in various channels.


basic_args() {
    # Parses basic commandline arguments and sets basic environment.
    #
    # Args:
    #     parameters - an array of commandline arguments
    #
    # Side effects:
    #     Exits if --help parameters is used
    #     Sets COLOR constants and debug variable

    local parameters=( "$@" )

    RED="\\033[1;31m"
    YELLOW="\\033[1;33m"
    GREEN="\\033[1;32m"
    BOLD="\\033[1m"
    RESET="\\033[0m"
    for parameter in "${parameters[@]}"; do
        if [[ "$parameter" == "-h" || "$parameter" == "--help" ]]; then
            echo "Usage: $( basename "$0" ) [-n | --no-colors] [-d | --debug]"
            exit 1
        elif [[ "$parameter" == "-n" || "$parameter" == "--no-colors" ]]; then
            RED=""
            YELLOW=""
            GREEN=""
            BOLD=""
            RESET=""
        elif [[ "$parameter" == "-d" || "$parameter" == "--debug" ]]; then
            debug=true
        fi
    done
}


basic_reqs() {
    # Prints common disclaimer and checks basic requirements.
    #
    # Args:
    #     CVE - string printed in the disclaimer
    #
    # Side effects:
    #     Exits when 'rpm' command is not available

    local CVE="$1"

    # Disclaimer
    echo
    echo -e "${BOLD}This script (v$VERSION) is primarily designed to detect $CVE on supported"
    echo -e "Red Hat Enterprise Linux systems and kernel packages."
    echo -e "Result may be inaccurate for other RPM based systems.${RESET}"
    echo

    # RPM is required
    if ! command -v rpm &> /dev/null; then
        echo "'rpm' command is required, but not installed. Exiting."
        exit 1
    fi
}


check_supported_kernel() {
    # Checks if running kernel is supported.
    #
    # Args:
    #     running_kernel - kernel string as returned by 'uname -r'
    #
    # Side effects:
    #     Exits when running kernel is obviously not supported

    local running_kernel="$1"

    # Check supported platform
    if [[ "$running_kernel" != *".el"[5-7]* ]]; then
        echo -e "${RED}This script is meant to be used only on RHEL 5, 6 and 7.${RESET}"
        exit 1
    fi
}


get_rhel() {
    # Gets RHEL number.
    #
    # Args:
    #     running_kernel - kernel string as returned by 'uname -r'
    #
    # Prints:
    #     RHEL number, e.g. '5', '6', or '7'

    local running_kernel="$1"

    local rhel
    rhel=$( sed -r -n 's/^.*el([[:digit:]]).*$/\1/p' <<< "$running_kernel" )
    echo "$rhel"
}


gather_info_vulnerability_file() {
    # Checks vulnerability file and stores relevant flags.
    #
    # Side effects:
    #     Sets global flags relevant to vulnerability file. Exits if vulnerability file exists
    #     but cannot be read.
    #
    # Notes:
    #     MOCK_VULNS_PATH can be used to mock /sys/devices/system/cpu/vulnerabilities path

    local vulns=${MOCK_VULNS_PATH:-/sys/devices/system/cpu/vulnerabilities}

    # Check if file from updated kernel is available and can be read
    if [[ -f "${vulns}/spec_store_bypass" ]]; then
        if [[ -r "${vulns}/spec_store_bypass" ]]; then
            vulnerability_file_present=1
            updated_kernel=1
        else
            echo "Cannot read existing file '${vulns}/spec_store_bypass'."
            echo "Please execute script with necessary privileges."
            exit 1
        fi
    else
        vulnerability_file_present=0
        updated_kernel=0
    fi

    # Read the vulnerability file
    if (( vulnerability_file_present )); then
        # Possible values:
        # "Not affected", "Vulnerable", "Mitigation: Speculative Store Bypass disabled",
        # "Mitigation: Speculative Store Bypass disabled via prctl"
        spec_store_bypass=$( <"${vulns}/spec_store_bypass" )
    fi

    # Parse result from reading the file, the result is empty if file does not exist
    if [[ "$spec_store_bypass" == *"Vulnerable"* ]]; then
        vulnerable_from_kernel=1
        not_affected_from_kernel=0
    elif [[ "$spec_store_bypass" == *"Not affected"* ]]; then
        vulnerable_from_kernel=0
        not_affected_from_kernel=1
    elif [[ "$spec_store_bypass" == *"Mitigation"* ]]; then
        vulnerable_from_kernel=0
        not_affected_from_kernel=0
    else
        vulnerable_from_kernel=1
        not_affected_from_kernel=0
    fi
}


gather_info_commandline() {
    # Checks if mitigation is disabled on commandline.
    #
    # Side effects:
    #     Sets global flags relevant to commandline
    #
    # Notes:
    #     MOCK_CMDLINE_PATH can be used to mock /proc/cmdline file

    local cmdline_path=${MOCK_CMDLINE_PATH:-/proc/cmdline}

    # Check commandline
    spec_store_bypass_disable=0
    nospec_store_disable=0
    if grep --quiet 'spec_store_bypass_disable=off' "$cmdline_path"; then
        spec_store_bypass_disable=1
    fi
    if grep --quiet 'nospec_store_disable' "$cmdline_path"; then
        nospec_store_disable=1
    fi
}


read_array() {
    # Reads lines from stdin and saves them in a global array referenced by a name.
    # It is a poor man's readarray compatible with Bash 3.1.
    #
    # Args:
    #     array_name - name of the global array
    #
    # Side effects:
    #     Overwrites content of the array 'array_name' with lines from stdin
    local array_name="$1"

    local i=0
    while IFS= read -r line; do
        read -r "$array_name[$(( i++ ))]" <<< "$line"
    done
}


X86_VENDOR_NSC="Geode by NSC"
X86_VENDOR_INTEL="GenuineIntel"
X86_VENDOR_CENTAUR="CentaurHauls"
X86_VENDOR_AMD="AuthenticAMD"
X86_VENDOR_ANY=""

INTEL_FAM6_ATOM_PINEVIEW=$(( 0x1C ))
INTEL_FAM6_ATOM_LINCROFT=$(( 0x26 ))
INTEL_FAM6_ATOM_PENWELL=$(( 0x27 ))
INTEL_FAM6_ATOM_CLOVERVIEW=$(( 0x35 ))
INTEL_FAM6_ATOM_CEDARVIEW=$(( 0x36 ))
INTEL_FAM6_ATOM_SILVERMONT1=$(( 0x37 ))  # BayTrail/BYT / Valleyview
INTEL_FAM6_ATOM_AIRMONT=$(( 0x4C ))      # CherryTrail / Braswell
INTEL_FAM6_ATOM_SILVERMONT2=$(( 0x4D ))  # Avaton/Rangely
INTEL_FAM6_ATOM_MERRIFIELD=$(( 0x4A ))   # Tangier
INTEL_FAM6_CORE_YONAH=$(( 0x0E ))
INTEL_FAM6_XEON_PHI_KNL=$(( 0x57 ))      # Knights Landing
INTEL_FAM6_XEON_PHI_KNM=$(( 0x85 ))      # Knights Mill
MODEL_ALL=""

NOT_AFFECTED=( "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_PINEVIEW"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_LINCROFT"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_PENWELL"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_CLOVERVIEW"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_CEDARVIEW"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_SILVERMONT1"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_AIRMONT"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_SILVERMONT2"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_ATOM_MERRIFIELD"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_CORE_YONAH"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_XEON_PHI_KNL"
               "$X86_VENDOR_INTEL"           6     "$INTEL_FAM6_XEON_PHI_KNM"
               "$X86_VENDOR_CENTAUR"         5     "$MODEL_ALL"
               "$X86_VENDOR_INTEL"           5     "$MODEL_ALL"
               "$X86_VENDOR_NSC"             5     "$MODEL_ALL"
               "$X86_VENDOR_AMD"      $(( 0x12 ))  "$MODEL_ALL"
               "$X86_VENDOR_AMD"      $(( 0x11 ))  "$MODEL_ALL"
               "$X86_VENDOR_AMD"      $(( 0x10 ))  "$MODEL_ALL"
               "$X86_VENDOR_AMD"      $(( 0xf  ))  "$MODEL_ALL"
               "$X86_VENDOR_ANY"             4     "$MODEL_ALL"
              )


check_not_affected_cpu() {
    # Checks if all CPUs on the system are not affected.
    #
    # Returns:
    #     0 if all CPUs are not affected, 1 otherwise
    #
    # Notes:
    #     MOCK_CPU_INFO_PATH can be used to mock /proc/cpuinfo file

    local cpuinfo=${MOCK_CPU_INFO_PATH:-/proc/cpuinfo}

    local vendor
    local family
    local model
    local i
    local j
    local affected

    vendors=()
    families=()
    models=()
    read_array vendors <<< "$( sed -rn 's/vendor_id\s+: (.*)/\1/p' "$cpuinfo" )"
    read_array families <<< "$( sed -rn 's/cpu family\s+: (.*)/\1/p' "$cpuinfo" )"
    read_array models <<< "$( sed -rn 's/model\s+: (.*)/\1/p' "$cpuinfo" )"

    local length_cpus="${#vendors[@]}"
    local length_tests=$(( ${#NOT_AFFECTED[@]} / 3 ))

    for (( i = 0; i < length_cpus; i++ )); do
        vendor="${vendors[i]}"
        family="${families[i]}"
        model="${models[i]}"

        affected=1
        for (( j = 0; j < length_tests; j++ )); do
            tested_vendor="${NOT_AFFECTED[j*3]}"
            tested_family="${NOT_AFFECTED[j*3 + 1]}"
            tested_model="${NOT_AFFECTED[j*3 + 2]}"

            if [[ "$vendor" == "$tested_vendor" || "$tested_vendor" == "$X86_VENDOR_ANY" ]]; then
                if (( family == tested_family )); then
                    if (( model == tested_model )) || [[ "$tested_model" == "$MODEL_ALL" ]]; then
                        affected=0
                        break
                    fi
                fi
            fi
        done
        if (( affected )); then
            return 1  # Affected
        fi
    done
    return 0  # Not affected
}


if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    basic_args "$@"
    basic_reqs "CVE-2018-3639"
    running_kernel=$( uname -r )
    check_supported_kernel "$running_kernel"

    rhel=$( get_rhel "$running_kernel" )
    if [[ "$rhel" == "5" ]]; then
        export PATH='/sbin':$PATH
    fi

    # Flags and variables
    vulnerability_file_present=0
    updated_kernel=0
    spec_store_bypass=""
    vulnerable_from_kernel=0
    not_affected_from_kernel=0
    spec_store_bypass_disable=0
    nospec_store_disable=0

    # Checks
    gather_info_vulnerability_file
    gather_info_commandline
    check_not_affected_cpu
    # shellcheck disable=SC2181
    not_affected_from_cpuinfo=$(( !$? ))  # store 1 as True, 0 as False

    # Either kernel can report that CPU is not affected or fallback check can report the same
    # if the kernel is not updated yet
    not_affected=$(( not_affected_from_kernel || not_affected_from_cpuinfo ))

    # Either kernel can report vulnerable system, or if kernel is not updated, then systems which
    # have affected CPUs are vulnerable
    vulnerable=$(( vulnerable_from_kernel || (!not_affected && !updated_kernel) ))

    # If kernel is updated and mitigation is not disabled, but it is still vulnerable, then
    # microcode is not updated
    microcode_not_updated=$(( updated_kernel && vulnerable \
                              && !spec_store_bypass_disable && !nospec_store_disable ))

    # Debug prints
    if [[ "$debug" ]]; then
        variables=( vulnerability_file_present updated_kernel spec_store_bypass
                    vulnerable_from_kernel not_affected_from_kernel not_affected_from_cpuinfo
                    spec_store_bypass_disable nospec_store_disable
                    not_affected vulnerable microcode_not_updated
                    )
        for variable in "${variables[@]}"; do
            echo "$variable = *${!variable}*"
        done
        declare -p vendors
        declare -p families
        declare -p models
        echo
    fi

    # Results
    if (( not_affected )); then
        echo -e "This system is ${GREEN}not affected${RESET}, because none of its CPUs are affected."
        exit 0
    elif (( vulnerable )); then
        echo -e "This system is ${RED}vulnerable${RESET} for the following reasons:"
        if (( !updated_kernel )); then
            echo -e "* Kernel is not updated"
            echo -e "* CPU microcode may require an update (cannot be determined without updated kernel)"
        fi
        if (( spec_store_bypass_disable )); then
            echo -e "* Mitigation is disabled by 'spec_store_bypass_disable=off' commandline parameter"
        fi
        if (( nospec_store_disable )); then
            echo -e "* Mitigation is disabled by 'nospec_store_disable' commandline parameter"
        fi
        if (( microcode_not_updated )); then
            echo -e "* CPU microcode is not updated"
        fi
        echo
        echo -e "Follow $ARTICLE for advice."
        exit 2
    else
        echo -e "This system is ${GREEN}not vulnerable${RESET}, because it has correct mitigation applied."
        exit 0
    fi
fi
